#include <chrono>
#include <memory>
#include "rclcpp/rclcpp.hpp"
{{- range .Includes}}
#include "{{.}}"
{{- end}}

// Placeholders
{{- $meta := .}}
using std::placeholders::_1;
using FilterPolicy = {{$meta.FilterPolicy}}<{{$meta.MsgType}}, {{$meta.MsgType}}>;
{{- $executor := .Executor}}
{{- $executor_id := $executor.ID}}
{{range $executor.Nodes}}
class N{{.ID}} : public rclcpp::Node
{
private:
{{- range .Callbacks}}
	{{- $callback := .}}
    {{- if .Timer}}
    rclcpp::TimerBase::SharedPtr timer_{{.ID}};
    {{- end}}
    {{- range $i, $from := .Topics_rx}}
    {{- $ch := index $callback.Topics_cx $i}}
    {{- if eq $from -1}}
    {{else}}
    rclcpp::Subscription<{{$meta.MsgType}}>::SharedPtr sub_{{$from}}_{{$callback.ID}}_{{$ch}};
    {{- end}}
    {{- end}}
    {{- range $i, $to := .Topics_tx}}
    {{- $ch := index $callback.Topics_cx $i}}
    {{- if eq $to -1}}
    {{- else}}
    rclcpp::Publisher<{{$meta.MsgType}}>::SharedPtr pub_{{$callback.ID}}_{{$to}}_{{$ch}};
    {{- end}}
    {{- end}}
{{- end}}

{{- range .Filters}}
	{{- $filter := .}}
	{{- range $i, $from := .Topics_rx}}
	{{- $to := index $filter.Topics_tx $i}}
	{{- $ch := index $filter.Topics_cx $i}}
	message_filters::Subscriber<{{$meta.MsgType}}> sub_{{$from}}_{{$filter.ID}}_{{$ch}};
	rclcpp::Publisher<{{$meta.MsgType}}>::SharedPtr pub_{{$filter.ID}}_{{$to}}_{{$ch}};
	{{- end}}
{{- end}}

	// Standard callbacks
{{- range .Callbacks}}
	{{- $callback := .}}
	void C{{.ID}} ({{- if .Timer}}{{else}}{{$meta.MsgType}}::SharedPtr msg_p, std::string topic{{end}})
	{
		// WCET ~{{.WCET}}ns via TACLe benchmarks
		for (int i = 0; i < {{.Repeats}}; ++i) {
			{{- if eq .Benchmark ""}}
			// No suitable benchmark found (!)
			{{- else }}
			{{.Benchmark}}();
			{{- end}}
		}

		{{- if .Timer}}
		// Get timestamp
		auto timestamp_ns = std::chrono::time_point_cast<std::chrono::nanoseconds>(
			std::chrono::steady_clock::now());
		auto value_ns = timestamp_ns.time_since_epoch();
		std_msgs::msg::Int64 msg_p;
		msg_p.data = value_ns.count();
		{{- end}}

		// Relay
		{{- range $i, $from := .Topics_rx}}
		{{- $to := index $callback.Topics_tx $i}}
		{{- $ch := index $callback.Topics_cx $i}}

		{{- if eq $to -1}}
		{{- if eq $from -1}}
		// TODO: Publish timing information (one off timer)
		{{- else}}
		if (topic == "T_N{{$from}}_N{{$callback.ID}}_C{{$ch}}") {
			// TODO: Publish timing information
			return;
		}
		{{- end}}
		{{- else}}
		{{- if eq $from -1}}
		pub_{{$callback.ID}}_{{$to}}_{{$ch}}->publish(msg_p);
		{{- else}}
		if (topic == "T_N{{$from}}_N{{$callback.ID}}_C{{$ch}}") {
			pub_{{$callback.ID}}_{{$to}}_{{$ch}}->publish(*msg_p);
		}
		}
		}
		{{- end}}
		{{- end}}
		{{- end}}
	}
{{- end}}

	// Message filter callbacks
{{- range .Filters}}
	{{- $filter := .}}
	void C{{.ID}} ({{$meta.MsgType}}::SharedPtr msg_0, {{$meta.MsgType}}::SharedPtr msg_1)
	{
		{{- range $i, $to := .Topics_tx}}
		{{- $ch := index $filter.Topics_cx $i}}
		pub_{{$filter.ID}}_{{$to}}_{{$ch}}->publish(*msg_{{$i}});
		{{- end}}
	}
{{- end}}

public:
	{{$node_id := .ID}}
	N{{$node_id}}(): Node("N{{.ID}}", rclcpp::NodeOptions().start_parameter_event_publisher(false))
	{
		// Init timers
		{{- range .Callbacks}}
		{{- if .Timer}}
		{{- if $meta.PPE}}
		timer_{{.ID}} = this->create_wall_timer(std::chrono::nanoseconds({{.Period}}),
			std::bind(&N{{$node_id}}::C{{.ID}}, this), nullptr, {{.Priority}});
		{{- else}}
		timer_{{.ID}} = this->create_wall_timer(std::chrono::nanoseconds({{.Period}}),
			std::bind(&N{{$node_id}}::C{{.ID}}, this), nullptr);
		{{- end}}
		{{- end}}
		{{- end}}

		// Init publishers
		{{- range .Callbacks}}
		{{- $callback := .}}
		{{- range $i, $to := .Topics_tx}}
		{{- $from := index $callback.Topics_rx $i}}
		{{- $ch := index $callback.Topics_cx $i}}
		{{- if eq $to -1}}
		{{- else}}
		pub_{{$callback.ID}}_{{$to}}_{{$ch}} = this->create_publisher<{{$meta.MsgType}}>("T_N{{$callback.ID}}_N{{$to}}_C{{$ch}}", 10);
		{{- end}}
		{{- end}}
		{{- end}}

		// Init subscriptions
		{{- range .Callbacks}}
		{{- $callback := .}}
		{{- range $i, $to := .Topics_tx}}
		{{- $from := index $callback.Topics_rx $i}}
		{{- $ch := index $callback.Topics_cx $i}}
		{{- if eq $from -1}}
		{{- else}}
		std::function<void(const {{$meta.MsgType}}::SharedPtr msg_p)> f{{$i}} = std::bind(&N{{$node_id}}::C{{$callback.ID}}, this, std::placeholders::_1, "T_N{{$from}}_N{{$callback.ID}}_C{{$ch}}");
		{{- if $meta.PPE}}
		sub_{{$from}}_{{$callback.ID}}_{{$ch}} = this->create_priority_subscription<{{$meta.MsgType}}>("T_N{{$from}}_N{{$callback.ID}}_C{{$ch}}", 10,
			f{{$i}}, {{$callback.Priority}});
		{{- else}}
		sub_{{$from}}_{{$callback.ID}}_{{$ch}} = this->create_subscription<{{$meta.MsgType}}>("T_N{{$from}}_N{{$callback.ID}}_C{{$ch}}", 10,
			f{{$i}});
		{{- end}}
		{{- end}}
		{{- end}}
		{{- end}}

		// Init message filter publishers and subscriptions
		{{- range $i, $filter := .Filters}}
		message_filters::Synchronizer<FilterPolicy> filter_{{$filter.ID}}(
			FilterPolicy(10){{range $j, $from := $filter.Topics_rx}}{{- $ch := index $filter.Topics_cx $j}},  sub_{{.}}_{{$filter.ID}}_{{$ch}}{{end}});
		filter_{{$filter.ID}}.registerCallback(&N{{$node_id}}::C{{$filter.ID}}, this);
		{{- end}}
	}
};
{{end}}

int main (int argc, char *argv[])
{
	rclcpp::init(argc, argv);

	// Init nodes
	{{- range $executor.Nodes}}
	auto node_N{{.ID}} = std::make_shared<N{{.ID}}>();
	{{- end}}

	// Init executor
	{{- if $meta.PPE}}
	rclcpp::executors::PreemptivePriorityExecutor exec(rclcpp::ExecutorOptions(), {50,99}, rclcpp::executors::P_FP);
	{{- else}}
	rclcpp::executors::SingleThreadedExecutor exec;
	{{- end}}

	// Add nodes
	{{- range $executor.Nodes}}
	exec.add_node(node_N{{.ID}});
	{{- end}}

	// Spin (for hyper-period)
	// TODO: implement some kind of spin functionality with a timeout, and a callback
	exec.spin();

	// Stop
	rclcpp::shutdown();

	return EXIT_SUCCESS;
}
